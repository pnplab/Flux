package org.pnplab.phenotype.system.entrypoints;

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.hardware.TriggerEvent;
import android.hardware.TriggerEventListener;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.NetworkOnMainThreadException;

import androidx.annotation.RequiresApi;

import com.rabbitmq.client.BlockedListener;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Recoverable;
import com.rabbitmq.client.RecoveryListener;
import com.rabbitmq.client.ShutdownListener;
import com.rabbitmq.client.ShutdownSignalException;
import com.rabbitmq.client.impl.recovery.AutorecoveringConnection;

import org.pnplab.phenotype.logger.AbstractLogger;
import org.pnplab.phenotype.synchronization.remote.RabbitConnection;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.concurrent.TimeoutException;

import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.disposables.Disposable;

// @todo
// 1. upload on server to Timeseries Db
// 2. check sensors missing timepoints through visualisation.

// https://developer.android.com/topic/performance/power/setup-battery-historian
// https://developer.android.com/topic/performance/power/battery-historian
public class DeprecatedPhenotypeService extends AbstractPhenotypeService {
    // int numberOfCores = Runtime.getRuntime().availableProcessors();
    // ThreadPoolExecutor taskExecutor = new ThreadPoolExecutor(numberOfCores, 32, 5000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(50));
    // executor.setRejectedExecutionHandler
    // https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f
    // https://medium.com/@frank.tan/using-handlerthread-in-android-46c285936fdd
    // taskExecutor.prestartAllCoreThreads();
    // taskExecutor.awaitTermination();

    final AbstractLogger _log = AbstractPhenotypeInitProvider.getLogger();

    Thread _engineThread = new Thread(() -> {
        // Ping service every 5 seconds and report to log.
        while (!Thread.currentThread().isInterrupted()) {
            String timestamp = "" + System.currentTimeMillis();

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
                LocalDateTime now = LocalDateTime.now();
                timestamp += " " + dtf.format(now);
            }

            _log.v(timestamp + " ping service");
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {

            }
        }
    });

    Thread _rabbitMqThread = new Thread(() -> {

        Observable<Channel> connectionObservable = RabbitConnection.get();
        @NonNull Disposable dispose = connectionObservable
                .subscribe(channel -> {
                    if (channel == null) {

                    }
                    else {

                    }
                });

        HandlerThread sensorThread = new HandlerThread("PhenotypeEngine");
        sensorThread.start();
        Handler sensorThreadHandler = new Handler(sensorThread.getLooper());

        SensorManager _sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);

        {
            final Sensor _significanMotion = _sensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);

            boolean isWakeUp = true; // unknown.. @todo know!
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                isWakeUp = _significanMotion.isWakeUpSensor();
            }
            int maxEventCount = _significanMotion.getFifoMaxEventCount();
            int frequency = 50;
            int maxReportLatencyUs = (1000000 / frequency) * maxEventCount;
            _log.i("sm:isWakeUp:" + isWakeUp);
            _log.i("sm:frequency:" + frequency);
            _log.i("sm:maxEventCount:" + maxEventCount);
            _log.i("sm:maxReportLatencyUs:" + maxReportLatencyUs);

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                int reportingMode = _significanMotion.getReportingMode();
                if (reportingMode == Sensor.REPORTING_MODE_ONE_SHOT) {
                    _log.i("sm:reportingMode:oneShot");
                }
                else {
                    _log.i("sm:reportingMode:" + reportingMode);
                }
            }

            // @question from that.

            // @todo drop without buffer - interpolation strategy to recover.
            Flowable
                .<TriggerEvent>create(producer -> {
                    final TriggerEventListener triggerEventListener = new TriggerEventListener() {
                        @Override
                        public void onTrigger(TriggerEvent event) {
                            // Forward event into flowable.
                            producer.onNext(event);

                            // Loop trigger.
                            // @todo find a way to put retrigger request
                            //     outside of flowable creation in order to
                            //     benefits sooner from flowable backpressure
                            //     management.
                            boolean requestSucceed = _sensorManager.requestTriggerSensor(this, _significanMotion);

                            // End flowable in case of request failure, just
                            // for cleanity.
                            if (!requestSucceed) {
                                producer.onError(new RuntimeException("requestTriggerSensor for significant motion has failed"));
                            }
                        }
                    };
                    boolean requestSucceed = _sensorManager.requestTriggerSensor(triggerEventListener, _significanMotion);
                    _log.i("sm:requestSucceed:" + requestSucceed);
                }, BackpressureStrategy.DROP)
                .subscribe(event -> {
                    String timestamp = "" + System.currentTimeMillis();
                    long evtTimestamp = event.timestamp;
                    _log.v("sm " + timestamp + " " + event.timestamp + " " + event.values.length + " " + event.values[0]);
                });
        }

        {
            final Sensor _accelerometer = _sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            boolean isWakeUp = false; // unknown.. should be false by default though @todo know!
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                isWakeUp = _accelerometer.isWakeUpSensor();
            }
            /*
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                // @note _sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER, true) returns null.
                List<Sensor> dynamicSensorList = _sensorManager.getDynamicSensorList(Sensor.TYPE_ACCELEROMETER);
                for (Sensor dynamicSensor : dynamicSensorList) {
                    if (dynamicSensor.isWakeUpSensor()) {
                        _accelerometer = dynamicSensor;
                        isWakeUp = true;
                    }
                }
            }
            */
            int maxEventCount = _accelerometer.getFifoMaxEventCount();
            int frequency = 50;
            int maxReportLatencyUs = (1000000 / frequency) * maxEventCount;
            _log.i("accelerometer:isWakeUp:" + isWakeUp);
            _log.i("accelerometer:frequency:" + frequency);
            _log.i("accelerometer:maxEventCount:" + maxEventCount);
            _log.i("accelerometer:maxReportLatencyUs:" + maxReportLatencyUs);

            Flowable
                .<SensorEvent>create(producer -> {
                    _sensorManager.registerListener(new SensorEventListener() {
                        @Override
                        public void onSensorChanged(SensorEvent event) {
                            // Forward event into flowable.
                            producer.onNext(event);
                        }

                        @Override
                        public void onAccuracyChanged(Sensor sensor, int accuracy) {

                        }
                    }, _accelerometer, 1000000 / frequency, sensorThreadHandler);
                }, BackpressureStrategy.DROP)
                /*
                .buffer(frequency)
                .subscribe(events -> {
                    events.forEach(event -> {
                        // SystemClock.elapsedRealtimeNanos()
                        long timestamp = System.currentTimeMillis();
                        // _log.v("" + timestamp + " " + event.timestamp + " " + event.values[0] + " " + event.values[1] + " " + event.values[2]);
                        try {
                            ByteBuffer buffer = ByteBuffer.allocate(1 * 8 + 3 * 4); // Always big endian by default
                            buffer.putLong(timestamp);
                            buffer.putFloat(event.values[0]);
                            buffer.putFloat(event.values[1]);
                            buffer.putFloat(event.values[2]);
                            channel.basicPublish("", "accelerometer", null, buffer.array());
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    });
                });
                 */
                .subscribe(event -> {
                    // SystemClock.elapsedRealtimeNanos()
                    long timestamp = System.currentTimeMillis();
                    // _log.v("" + timestamp + " " + event.timestamp + " " + event.values[0] + " " + event.values[1] + " " + event.values[2]);
                    // try {
                        ByteBuffer buffer = ByteBuffer.allocate(1 * 8 + 3 * 4); // Always big endian by default
                        buffer.putLong(timestamp);
                        buffer.putFloat(event.values[0]);
                        buffer.putFloat(event.values[1]);
                        buffer.putFloat(event.values[2]);
                        // channel.basicPublish("", "accelerometer", null, buffer.array());
                    // } catch (IOException e) {
                    //     e.printStackTrace();
                    // }
                });

            // @todo pipe that in remote storage until we see worker queue to flush local storage into remote storage!
            // @warning we still want real time communication
            // @todo pipe that in local storage!
        }

    });

    @RequiresApi(api = Build.VERSION_CODES.N)
    @Override
    protected void _onStartEngine() {
        _engineThread.start();
        _rabbitMqThread.start();
        // https://developer.android.com/guide/components/broadcast-exceptions
        // https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html
    }

    @Override
    protected void _onStopEngine() {
        _engineThread.interrupt();
    }
}
